cells:
  - kind: 1
    value: |-
      # Oracle Database 23ai Vector Search 주요 기능 알아보기

      우측 아래 **No connection attached**에서 만든 Connection 중에서 vector 유저용을 선택합니다.
    languageId: markdown
  - kind: 1
    value: |-
      ## 1. VECTOR Data Type
      Oracle Database 23ai에 DB 테이블 칼럼의 데이터 타입으로 VECTOR를 지원에 대해 테스트합니다.
    languageId: markdown
  - kind: 1
    value: 1. 테이블을 생성하고 VECTOR 타입 데이터를 추가합니다.
    languageId: markdown
  - kind: 2
    value: |-
      --DROP TABLE colors PURGE;

      CREATE TABLE colors(
          id number, 
          name CLOB, 
          color_vector VECTOR(3, FLOAT32));

      INSERT INTO colors VALUES (1, 'Lime', TO_VECTOR('[0, 255, 0]'));
      INSERT INTO colors VALUES (1, 'Yellow', TO_VECTOR('[255, 255, 0]'));
      INSERT INTO colors VALUES (1, 'Red', TO_VECTOR('[255, 0, 0]'));
      INSERT INTO colors VALUES (1, 'Gold', '[255, 215, 0]');
      INSERT INTO colors VALUES (1, 'Orange', '[255, 165, 0]');
      COMMIT;
    languageId: oracle-sql
  - kind: 1
    value: 2. VECTOR 타입 데이터가 잘 입력되었는지 데이터를 조회해 확인합니다.
    languageId: markdown
  - kind: 2
    value: SELECT * FROM colors;
    languageId: oracle-sql
  - kind: 1
    value: 3. FROM_VECTOR 함수를 통해 문자열로 변환해 본다. 여기서 차이를 느끼진 못합니다.
    languageId: markdown
  - kind: 2
    value: SELECT id, name, FROM_VECTOR(color_vector) FROM colors;
    languageId: oracle-sql
  - kind: 1
    value: 4. VECTOR의 차원과 형식을 조회할 수 있습니다.
    languageId: markdown
  - kind: 2
    value: SELECT VECTOR_DIMENSION_COUNT(color_vector),
      VECTOR_DIMENSION_FORMAT(color_vector) FROM colors WHERE ROWNUM=1;
    languageId: oracle-sql
  - kind: 1
    value: |-
      ## 2. Vector Embedding
      VECTOR 데이터타입에 값 입력을 위해 Embedding을 하는 방법을 알아봅니다.
    languageId: markdown
  - kind: 1
    value: |-
      ### 2.1 Use Pre-Created Embeddings
      문자열로 표현된 Vector를 VECTOR 데이터타입으로 형변환하는 것을 지원합니다. 
      이미 Embedding된 데이터를 VECTOR 칼럼에 로딩하는 방법입니다.
    languageId: markdown
  - kind: 1
    value: |-
      **SQLcl에 실행하는 작업입니다**

      SQL Developer 탭에서 Connection을 우클릭 후, SQLcl을 클릭하여, SQLcl을 실행합니다. LOAD 기능을 사용하기 위해 **SQLcl**을 사용합니다.

      업로드할 csv 파일이 있는 위치로 이동하여, 아래와 같이 데이터를 로드합니다.

      DATAGO_SEOUL_2022.RSTR_INFO_KOREAN_10000_paraphrase-multilingual.csv 파일에서 vector_description 칼럼은
      이미, ollama상의 paraphrase-multilingual 모델을 통해 이미 임베딩된 값이 포함되어 있습니다.

      ```sql
      SQL> pwd                                                                                                                              
      /home/opc/                                                                                                                            
      SQL> cd oracle-devday/data
      SQL>
      ```

      다음 Cell을 우클릭하여, Copy Cell을 클릭하여, 복사하여 SQLcl에서 실행합니다.
    languageId: markdown
  - kind: 1
    value: >-
      ```sql

      DROP TABLE rstr_info;

      DROP TABLE menu_info;


      CREATE TABLE VECTOR.RSTR_INFO
       (
        ID NUMBER(7),
        NAME VARCHAR2(128),
        BRANCH_NAME VARCHAR2(128),
        ADDRESS VARCHAR2(128),
        LAND_LOT_ADDRESS VARCHAR2(128),
        LATITUDE NUMBER(11, 7),
        LONGITUDE NUMBER(12, 7),
        PHONE_NUMBER VARCHAR2(30),
        BUSINESS_TYPE_REGISTERED VARCHAR2(50),
        BUSINESS_LICENSE_TYPE VARCHAR2(50),
        DESCRIPTION VARCHAR2(1024),
        VECTOR_DESCRIPTION VECTOR
       );

      LOAD rstr_info
      DATAGO_SEOUL_2022.RSTR_INFO_KOREAN_10000_paraphrase-multilingual.csv show;

      LOAD rstr_info
      DATAGO_SEOUL_2022.RSTR_INFO_KOREAN_10000_paraphrase-multilingual.csv;


      CREATE TABLE VECTOR.MENU_INFO
       (
        MENU_ID NUMBER(7),
        MENU_NAME VARCHAR2(128),
        MENU_PRICE NUMBER(10),
        IS_LOCAL_SPECIALTY NUMBER(3),
        LOCAL_SPECIALTY_NAME VARCHAR2(50),
        LOCAL_SPECIALTY_SOURCE_URL VARCHAR2(128),
        REGION_NAME VARCHAR2(50),
        RESTAURANT_ID NUMBER(7),
        RESTAURANT_NAME VARCHAR2(128),
        BRANCH_NAME VARCHAR2(50)
       );

      LOAD menu_info DATAGO_SEOUL_2022.MENU_INFO_KOREAN_100000.csv show;

      LOAD menu_info DATAGO_SEOUL_2022.MENU_INFO_KOREAN_100000.csv;

      ```
    languageId: markdown
  - kind: 1
    value: "**다음 Cell 같은 방법으로 복사하여 SQLcl에서 실행합니다.**"
    languageId: markdown
  - kind: 1
    value: |-
      ```sql
      DROP TABLE rstr_info_external;
      DROP TABLE rstr_info_internal;

      LOAD rstr_info_external DATAGO_SEOUL_2022.RSTR_INFO_KOREAN_TEST.csv new;
      LOAD rstr_info_internal DATAGO_SEOUL_2022.RSTR_INFO_KOREAN_TEST.csv new;
      ALTER TABLE rstr_info_external ADD vector_description VECTOR;
      ALTER TABLE rstr_info_internal ADD vector_description VECTOR;
      ```
    languageId: markdown
  - kind: 1
    value: 외부에서 로드되어 VECTOR 타입에 잘 로딩되었는지 확인합니다.
    languageId: markdown
  - kind: 2
    value: SELECT id, name, vector_description from rstr_info WHERE rownum<=5;
    languageId: oracle-sql
  - kind: 1
    value: |-
      ### 2.2 Use an external embedding service
      DBMS_VECTOR 패키지의 UTL_TO_EMBEDDING() 함수를 제공합니다.
      외부 Embedding 모델을 호출하여, vector로 임베딩하는 방법입니다.
    languageId: markdown
  - kind: 1
    value: DB에서 로컬에 있는 ollama 서버 호출을 통해 embedding 해봅니다. Binds 팝업이 뜨면, 그냥 Apply 합니다.
    languageId: markdown
  - kind: 2
    value: >-
      var params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('hello', json(:params)) as output FROM
      dual;
    languageId: oracle-sql
  - kind: 1
    value: rstr_info_external 테이블 대상으로 테스트해 봅니다. 아직 vector_description 칼럼값이 모두 null일
      것입니다.
    languageId: markdown
  - kind: 2
    value: SELECT id, name, vector_description FROM rstr_info_external;
    languageId: oracle-sql
  - kind: 2
    value: >-
      var params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      UPDATE rstr_info_external

      SET vector_description=DBMS_VECTOR.UTL_TO_EMBEDDING(description,
      json(:params));

      COMMIT;
    languageId: oracle-sql
  - kind: 1
    value: vector_description 칼럼이 업데이트된 것을 확인합니다.
    languageId: markdown
  - kind: 2
    value: SELECT id, name, vector_description FROM rstr_info_external;
    languageId: oracle-sql
  - kind: 1
    value: |-
      ### 2.3 Use a database resident embedding model
      ONNX 형식의 Embedding 모델을 데이터베이스 내부에 임포트하여 사용하는 것을 지원합니다.
      VECTOR_EMBEDDING() 함수를 통해 임포트한 Embedding 모델로  vector로 변환하는 방법입니다.
    languageId: markdown
  - kind: 1
    value: |-
      데이터베이스는 내에 임포트하기 위해서는 구성작업이 필요합니다. 여기서는 사전 구성된 모델을 이미 파일로 익스포트한 것을 그대로 사용합니다.

      다음 사이트에 관련 절차를 설명하고 있습니다.
      - https://practicalplsql.org/2025/05/25/oml4py-2-1-quickstart/

      이 사이트에 제공하는 파일 중에서 다음 링크에서 multilingual-e5-small.onnx 파일다운로드합니다.
      - https://drive.google.com/file/d/107o_3N_GVaaCkEeDzIpcHpkn7Gr3fd54/view?usp=drive_link
    languageId: markdown
  - kind: 1
    value: 파일을 데이터베이스가 있는 컨테이너로 업로드하기 전에 경로(DATA_PUMP_DIR)를 확인합니다.
    languageId: markdown
  - kind: 2
    value: SELECT directory_path FROM dba_directories WHERE
      directory_name='DATA_PUMP_DIR';
    languageId: oracle-sql
  - kind: 1
    value: >-
      **윈도우 실행창 또는 터미널에서 실행하는 작업입니다**


      다운 받은 ONNX 파일이 있는 경로로 이동하여, docker cli를 통해 컨테이너 내부로 다음 명령을 통해 파일 복사합니다.


      (directory_path가
      */opt/oracle/admin/FREE/dpdump/35CCB862513108F3E0630800580A0E6C*인 경우)
    languageId: markdown
  - kind: 1
    value: docker exec -it oracle-free-23ai ls -la /opt/oracle/admin/FREE/dpdump/
    languageId: markdown
  - kind: 1
    value: docker cp embedding-models/multilingual-e5-small.onnx
      oracle-free-23ai:/opt/oracle/admin/FREE/dpdump/35CCB862513108F3E0630800580A0E6C
    languageId: markdown
  - kind: 1
    value: 컨테이너 내부로 복사한 ONNX 파일을 사용하여, 데이터베이스로 임포트합니다.
    languageId: markdown
  - kind: 2
    value: |-
      BEGIN
      DBMS_VECTOR.LOAD_ONNX_MODEL(
      directory => 'DATA_PUMP_DIR',
      file_name => 'multilingual-e5-small.onnx',
      model_name => 'MULTILINGUAL_E5_SMALL');
      END;
      /
    languageId: oracle-sql
  - kind: 1
    value: 업로드된 모델을 확인합니다.
    languageId: markdown
  - kind: 2
    value: SELECT model_name, algorithm, mining_function FROM user_mining_models;
    languageId: oracle-sql
  - kind: 1
    value: 업로드된 모델로 embedding 해봅니다.
    languageId: markdown
  - kind: 2
    value: SELECT VECTOR_EMBEDDING(MULTILINGUAL_E5_SMALL USING 'hello' as data);
    languageId: oracle-sql
  - kind: 1
    value: rstr_info_internal 테이블 대상으로 테스트해 봅니다.
    languageId: markdown
  - kind: 2
    value: >-
      UPDATE rstr_info_internal

      SET vector_description=VECTOR_EMBEDDING(MULTILINGUAL_E5_SMALL USING
      description as data);

      COMMIT;
    languageId: oracle-sql
  - kind: 1
    value: vector_description 칼럼이 업데이트되 것을 확인합니다.
    languageId: markdown
  - kind: 2
    value: SELECT id, name, vector_description FROM rstr_info_internal;
    languageId: oracle-sql
  - kind: 1
    value: |-
      ## 3. Vector Search
      SQL에서 Vector간 유사도 검색을 지원합니다.
    languageId: markdown
  - kind: 1
    value: "`VECTOR_DISTANCE(VECTOR1, VECTOR2, <distance metric>)`과 같이 SQL내에서 함수로
      유사로 검색을 할 수 있습니다."
    languageId: markdown
  - kind: 1
    value: Gold색과 나머지 색들을 COSINE, EUCLIDEAN 두 방식으로 거리를 계산해 봅니다. 거리가 가까울수록 유사도가 높습니다.
    languageId: markdown
  - kind: 2
    value: >-
      SELECT colors.name, 
             TO_NUMBER(VECTOR_DISTANCE(colors.color_vector, TO_VECTOR('[255, 215, 0]'), COSINE)) as vector_distance, 
             'COSINE' as metric
      FROM colors

      ORDER BY vector_distance;


      SELECT colors.name, 
             TO_NUMBER(VECTOR_DISTANCE(colors.color_vector, TO_VECTOR('[255, 215, 0]'), EUCLIDEAN)) as vector_distance, 
             'EUCLIDEAN' as metric
      FROM colors

      ORDER BY vector_distance;
    languageId: oracle-sql
  - kind: 1
    value: >-
      ### 3.1 Vector Search #1 – SQL 내에서 유사도 검색(Similarity Search)

      문장형식의 질문을 Embedding 모델로 Query Vector로 변환하고, VECTOR_DISTANCE() 함수로 SQL내에서
      유사도 검색을 할 수 있습니다.
    languageId: markdown
  - kind: 2
    value: >-
      VARIABLE params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      VARIABLE query_vector CLOB;


      BEGIN
        SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('다국어 메뉴판이 있는 여의도 맛집', json(:params)) into :query_vector;
      END;

      /


      PRINT query_vector;

        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
      ORDER BY vector_distance
         FETCH FIRST 10 ROWS ONLY;
    languageId: oracle-sql
  - kind: 1
    value: |-
      ### 3.2 Vector Search #2 – SQL 내에서 관계형 질의 + 유사도 검색의 결합
      유사도 검색과 일반적인 관계형 질의에서의 조건문과 결합해서 사용할 수 있습니다.
    languageId: markdown
  - kind: 2
    value: >-
      VARIABLE params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      VARIABLE query_vector CLOB;


      BEGIN
        SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('다국어 메뉴판이 있는 여의도 맛집', json(:params)) into :query_vector;
      END;

      /


      PRINT query_vector;

        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
         WHERE business_type_registered='한식'
      ORDER BY vector_distance
         FETCH FIRST 10 ROWS ONLY;
    languageId: oracle-sql
  - kind: 1
    value: |-
      ### 3.2 Vector Search #3 – SQL 내에서 관계형 조인 질의 + 유사도 검색의 결합
      정규화된 관계형 테이블을 활용하려면, 테이블 조인이 필수이며, 기존 사용하고 있는 쿼리에서도 대부분 사용하고 있을 것입니다.
      테이블 조인에서도 유사도 검색을 함께 사용할 수 있습니다.
    languageId: markdown
  - kind: 2
    value: >-
      VARIABLE params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      VARIABLE query_vector CLOB;


      BEGIN
        SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('다국어 메뉴판이 있는 여의도 맛집', json(:params)) into :query_vector;
      END;

      /


      PRINT query_vector;

        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, menu_name, description
          FROM RSTR_INFO JOIN MENU_INFO ON RSTR_INFO.id = MENU_INFO.restaurant_id
         WHERE business_type_registered='한식' AND MENU_INFO.is_local_specialty=1
      ORDER BY vector_distance
         FETCH FIRST 10 ROWS ONLY;
    languageId: oracle-sql
  - kind: 1
    value: >-
      ## 4. Vector Index

      다차원인 VECTOR 타입에 대해서도 빠른 유사도 검색을 위해서는 인덱스가 필요합니다.

      VECTOR 컬럼은 다차원 배열(벡터) 구조이기 때문에, "크다/작다"를 정의할 수 있는 단일 기준이 없어, 정렬이 되지 않아,
      일반적인 인덱스와는 다른 인덱스가 필요합니다.
    languageId: markdown
  - kind: 1
    value: |-
      ### 4.1 HNSW(Hierarchical Navigable Small World) Index
      Index 생성시: 상위 레이어에는 Vertex(Vector)를 적게 두고 빠르게 탐색하도록 계층화하는 방식
      Index 검색시: 상위 레이어에서 부터 vq(query vector)로 가까운 지점으로 찾아가는 방식
    languageId: markdown
  - kind: 1
    value: HNSW 인덱스는 메모리 기반 인덱스로 메모리 할당이 필요합니다. 현재 할당이 되었는지 먼저 확인합니다. 지금은 할당된 메모리가
      없을 것입니다.
    languageId: markdown
  - kind: 2
    value: select * from V$VECTOR_MEMORY_POOL;
    languageId: oracle-sql
  - kind: 1
    value: |-
      할당이 되지 않은 경우 sysdba 유저로 변경 설정이 필요합니다.

      **윈도우 실행창 또는 터미널에서 실행하는 작업입니다**

      윈도우 실행창 또는 터미널에서 다음을 실행하여 oracle-free-23ai 컨테이너에 접속후 변경합니다.
      먼저 INDEX_VECTOR_MEMORY_ADVISOR을 실행하여, 필요량을 예상할 수 있습니다.
    languageId: markdown
  - kind: 2
    value: |-
      docker exec -it oracle-free-23ai sqlplus /nolog

      CONN sys/OracleIsAwesome@FREEPDB1 as sysdba

      SET SERVEROUTPUT ON;
      VARIABLE response_json CLOB;
      BEGIN
          DBMS_VECTOR.INDEX_VECTOR_MEMORY_ADVISOR(
          TABLE_OWNER=>'VECTOR',
          TABLE_NAME=>'RSTR_INFO',
          COLUMN_NAME=>'VECTOR_DESCRIPTION',
          INDEX_TYPE=>'HNSW',
          RESPONSE_JSON=> :response_json);
      END;
      /
    languageId: oracle-sql
  - kind: 1
    value: |-
      다음과 같은 결과를 볼 수 있습니다.

      ```text
      Using default accuracy: 90%
      Suggested vector memory pool size: 59918628 Bytes

      PL/SQL procedure successfully completed.
      ```
    languageId: markdown
  - kind: 1
    value: oracle-free-23ai 컨테이너 내부에서 CDB$ROOT의 메모리 풀 크기를 변경합니다. 다음은 512M로 변경하는
      예시입니다. 한꺼번에 실행시 몇 번 엔터키를 누릅니다.
    languageId: markdown
  - kind: 1
    value: |-
      ```text
      CONN sys/OracleIsAwesome as sysdba

      SHOW CON_NAME;
      ALTER SYSTEM SET vector_memory_size = 512M SCOPE = SPFILE;

      SHUTDOWN IMMEDIATE
      STARTUP
      ```
    languageId: markdown
  - kind: 1
    value: |-
      DB 재시작으로 연결이 끊어진 **우측 아래 DB Conection을 클릭하여, 연결 해제 후 다시 연결합니다.**

      메모리 풀이 변경이 되었는지 다시 확인합니다. 
    languageId: markdown
  - kind: 2
    value: select * from V$VECTOR_MEMORY_POOL;
    languageId: oracle-sql
  - kind: 1
    value: 인덱스 생성을 시도합니다. Vector의 차원수와 건수에 따라 인덱스 생성에 걸리는 시간이 달라집니다.
    languageId: markdown
  - kind: 2
    value: |-
      --DROP INDEX rstr_info_hnsw_idx;
      --DROP INDEX rstr_info_ivf_idx;

      CREATE VECTOR INDEX rstr_info_hnsw_idx ON rstr_info (vector_description)
      ORGANIZATION INMEMORY NEIGHBOR GRAPH
      DISTANCE COSINE
      WITH TARGET ACCURACY 70;  -- HNSW 인덱스가 근차시 인덱스를 확인시키기 위해 의도적으로 정확도 낮춤
    languageId: oracle-sql
  - kind: 1
    value: 또는 명시적으로 파리미터를 지정하여 인덱스를 생성할 수도 있습니다.
    languageId: markdown
  - kind: 2
    value: |-
      --DROP INDEX rstr_info_hnsw_idx;
      --DROP INDEX rstr_info_ivf_idx;

      CREATE VECTOR INDEX rstr_info_hnsw_idx ON rstr_info (vector_description)
      ORGANIZATION INMEMORY NEIGHBOR GRAPH
      DISTANCE COSINE
      PARAMETERS (type HNSW, neighbors 40, efconstruction 500);
    languageId: oracle-sql
  - kind: 1
    value: >-
      #### 4.1.1 HNSW Index 생성후 쿼리 재실행

      인덱스 생성후 앞서 실행한 "#2 – SQL 내에서 관계형 질의 + 유사도 검색의 결합"에 대한 실행 계획을 확인하여, 인덱스가
      사용되는 것을 확인합니다.
    languageId: markdown
  - kind: 2
    value: >-
      EXPLAIN PLAN FOR
        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
        WHERE business_type_registered='한식'
      ORDER BY vector_distance

      FETCH APPROX FIRST 10 ROWS ONLY;


      SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format => 'ALL'));   
    languageId: oracle-sql
  - kind: 1
    value: |-
      HNSW는 근사치 인덱스로, 인덱스가 있는 경우, 명시적으로 APPROX을 지정하지 않아도, **APPROX가 기본입니다.**
      아래와 같이 명시적으로 **EXACT** 입력후 다시 실행계획을 확인해 봅니다. 인덱스를 타지 않고, 전체 비교하게 됩니다.
    languageId: markdown
  - kind: 2
    value: >-
      EXPLAIN PLAN FOR
        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
        WHERE business_type_registered='한식'
      ORDER BY vector_distance

      FETCH EXACT FIRST 10 ROWS ONLY;


      SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format => 'ALL'));   
    languageId: oracle-sql
  - kind: 1
    value: |-
      APPROX 쿼리를 실행합니다. 
      9번째 식당의 이름을 확인합니다.
    languageId: markdown
  - kind: 2
    value: >-
      VARIABLE params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      VARIABLE query_vector CLOB;


      BEGIN
        SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('다국어 메뉴판이 있는 여의도 맛집', json(:params)) into :query_vector;
      END;

      /


      PRINT query_vector;

        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
         WHERE business_type_registered='한식'
      ORDER BY vector_distance
         FETCH APPROX FIRST 10 ROWS ONLY;
    languageId: oracle-sql
  - kind: 1
    value: "**EXACT** 쿼리를 실행합니다. "
    languageId: markdown
  - kind: 2
    value: >-
      VARIABLE params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      VARIABLE query_vector CLOB;


      BEGIN
        SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('다국어 메뉴판이 있는 여의도 맛집', json(:params)) into :query_vector;
      END;

      /


      PRINT query_vector;

        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
         WHERE business_type_registered='한식'
      ORDER BY vector_distance
         FETCH EXACT FIRST 10 ROWS ONLY;   
    languageId: oracle-sql
  - kind: 1
    value: |-
      9번째 식당의 이름을 확인합니다. 9번에 **남해횟집**이 있을 것입니다.

      **HNSW 인덱스는 근사치 인덱스로, 비용이 큰 EXACT 보다는 빠른 검색이 되지만, 결과에 다를 수 있음을 알수 있습니다.**
    languageId: markdown
  - kind: 1
    value: |-
      ### 4.2 Vector Index – IVF(Inverted File Flat Vector) Index
      Index 생성시: K-means 알로리즘을 이용하여 군집화(clustering)을 수행하는 방식
      Index 검색시: Query Vector와 각 중심점간 거리 계산 후 선정된 중심점내  Vector와 다시 계산
    languageId: markdown
  - kind: 1
    value: 인덱스 생성을 시도합니다. Vector의 차원수와 건수에 따라 인덱스 생성에 걸리는 시간이 달라집니다.
    languageId: markdown
  - kind: 2
    value: |-
      DROP INDEX rstr_info_hnsw_idx;
      --DROP INDEX rstr_info_ivf_idx;

      CREATE VECTOR INDEX rstr_info_ivf_idx ON rstr_info (vector_description)
      ORGANIZATION NEIGHBOR PARTITIONS
      DISTANCE COSINE
      WITH TARGET ACCURACY 95;
    languageId: oracle-sql
  - kind: 1
    value: 또는 명시적으로 파리미터를 지정하여 인덱스를 생성할 수도 있습니다.
    languageId: markdown
  - kind: 2
    value: |-
      --DROP INDEX rstr_info_hnsw_idx;
      --DROP INDEX rstr_info_ivf_idx;

      CREATE VECTOR INDEX rstr_info_ivf_idx ON rstr_info (vector_description)
      ORGANIZATION NEIGHBOR PARTITIONS
      DISTANCE COSINE
      PARAMETERS (type IVF, neighbor partitions 10);
    languageId: oracle-sql
  - kind: 1
    value: >-
      #### 4.2.1 IVF Index 생성후 쿼리 재실행

      인덱스 생성후 앞서 실행한 "#2 – SQL 내에서 관계형 질의 + 유사도 검색의 결합"에 대한 실행 계획을 확인하여, 인덱스가
      사용되는 것을 확인합니다.

      IVF도 근사치 인덱스입니다.
    languageId: markdown
  - kind: 2
    value: >-
      EXPLAIN PLAN FOR
        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
        WHERE business_type_registered='한식'
      ORDER BY vector_distance

      FETCH APPROX FIRST 10 ROWS ONLY;


      SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format => 'ALL'));   
    languageId: oracle-sql
  - kind: 1
    value: 쿼리를 실행합니다.
    languageId: markdown
  - kind: 2
    value: >-
      VARIABLE params clob;


      BEGIN

      :params := '{

      "provider": "ollama",

      "url" : "http://host.docker.internal:11434/api/embeddings", 

      "model" : "paraphrase-multilingual:latest"

      }';

      END;

      /


      VARIABLE query_vector CLOB;


      BEGIN
        SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('다국어 메뉴판이 있는 여의도 맛집', json(:params)) into :query_vector;
      END;

      /


      PRINT query_vector;

        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, :query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO
         WHERE business_type_registered='한식'
      ORDER BY vector_distance
         FETCH APPROX FIRST 10 ROWS ONLY;
         --FETCH EXACT FIRST 10 ROWS ONLY;  
    languageId: oracle-sql
  - kind: 1
    value: |-
      ### 4.3 Vector Index – Hybrid Vector Index
      Vector는 Vector Search 기능을 사용하고, 텍스트 키워드 검색은 Oracle Text를 사용합니다.
    languageId: markdown
  - kind: 1
    value: |-
      1. Oracle Text에서 한국어 인덱싱(조사구분, 복합명사 처리 등)을 위해 추가 Lexer를 설정을 해야합니다.
      - 참고 : [KOREAN_MORPH_LEXER Attributes](https://docs.oracle.com/en/database/oracle/oracle-database/19/ccref/oracle-text-indexing-elements.html#GUID-05408DB5-8629-4B16-BA70-E13FDDE583BA)
    languageId: markdown
  - kind: 2
    value: |-
      --BEGIN
      --  CTX_DDL.DROP_PREFERENCE('korean_lexer');
      --END;
      --/

      BEGIN
        CTX_DDL.CREATE_PREFERENCE('korean_lexer', 'KOREAN_MORPH_LEXER');
        CTX_DDL.SET_ATTRIBUTE('korean_lexer', 'COMPOSITE','NGRAM');
      END;
      /
    languageId: oracle-sql
  - kind: 1
    value: >-
      2. Hybrid Vector Index를 생성합니다.

      - 아래 명령으로 10000건 - Mac M1 Pro: 2분 31초 걸림 / GPU 없는 리눅스: 4분 16초

      - Hybrid Vector Index 생성시는 Embedding 모델은 **현재 데이터베이스 내부에 로드된 ONNX 모델만
      지원합니다.**

      - 아래 명령에서 볼수 있듯이, vector_description이 아닌, 인덱스하는 텍스트가 있는 description 컬럼을 직접
      지정한 것을 볼수 있습니다. Hybrid Vector Index 생성시점에 지정한 모델로 임베딩해서 인덱스를 만듭니다.
    languageId: markdown
  - kind: 2
    value: |-
      CREATE HYBRID VECTOR INDEX rstr_info_hybrid_idx
      ON rstr_info(description)
      PARAMETERS ('MODEL MULTILINGUAL_E5_SMALL
                   VECTOR_IDXTYPE IVF
                   LEXER korean_lexer');
    languageId: oracle-sql
  - kind: 1
    value: |-
      3. 인덱스를 사용해 조회합니다.
      INTERSECT 조건에 따라 Vector Search와 Text Search 결과가 모두 있는 결과를 가져옵니다.
      키워드는 반드시 포함하고, Vector 유사도와 조합하여 순위를 정렬합니다.
    languageId: markdown
  - kind: 2
    value: >-
      select JSON_QUERY(DBMS_HYBRID_VECTOR.SEARCH(
          json('{ "hybrid_index_name"     : "rstr_info_hybrid_idx",
                  "search_scorer": "rsf",
                  "search_fusion": "INTERSECT",
                  "vector":
                          { "search_text" : "다국어 메뉴판이 있는 여의도 맛집", "score_weight": 1 },
                  "text"  :
                          { "contains"    : "화장실", "score_weight": 1 },
                  "return":
                          { "topN"        : 10 }
                }')), '$' RETURNING CLOB PRETTY) 
      from dual;  
    languageId: oracle-sql
  - kind: 1
    value: |-
      4. 원 테이블과 조인한 결과를 확인합니다.
      KOREAN_MORPH_LEXER를 사용했기 때문에, "화장실이"가 문장에 있어도 조사 빼고 "화장실"로 잘 검색합니다.
    languageId: markdown
  - kind: 2
    value: >-
      SELECT b.score, b.vector_score, b.text_score, rstr.id, rstr.description,
      REGEXP_COUNT (rstr.description, '화장실') AS cnt
        FROM (SELECT DBMS_HYBRID_VECTOR.SEARCH (JSON (
                         '{
                              "hybrid_index_name": "rstr_info_hybrid_idx",
                              "search_scorer": "rsf",
                              "search_fusion": "INTERSECT",
                              "vector": {
                                  "search_text": "다국어 메뉴판이 있는 여의도 맛집"
                              },                        
                              "text": {
                                  "contains": "$화장실"
                              },
                              "return": {
                                  "values": ["rowid", "score", "vector_score", "text_score"],
                                  "topN": 20
                              }
                          }'
                     )) AS result) a
           , JSON_TABLE (a.result, '$[*]' COLUMNS (
                             rid          VARCHAR2(18) PATH '$.rowid'
                           , score        NUMBER       PATH '$.score'
                           , vector_score NUMBER       PATH '$.vector_score'
                           , text_score   NUMBER       PATH '$.text_score'
                         )) b
           , rstr_info rstr
       WHERE rstr.rowid = b.rid;   
    languageId: oracle-sql
  - kind: 1
    value: |-
      5. 아래와 같이 조회합니다.
      '주차', '화장실' 2개 키워드가 모두 있는 것을 찾습니다.
    languageId: markdown
  - kind: 2
    value: >-
      SELECT b.score, b.vector_score, b.text_score, rstr.id, rstr.description,
      REGEXP_COUNT (rstr.description, '주차|화장실') AS cnt
        FROM (SELECT DBMS_HYBRID_VECTOR.SEARCH (JSON (
                         '{
                              "hybrid_index_name": "rstr_info_hybrid_idx",
                              "search_scorer": "rsf",
                              "search_fusion": "INTERSECT",
                              "vector": {
                                  "search_text": "다국어 메뉴판이 있는 여의도 맛집"
                              },                        
                              "text": {
                                  "contains": "$주차 and $화장실"
                              },
                              "return": {
                                  "values": ["rowid", "score", "vector_score", "text_score"],
                                  "topN": 20
                              }
                          }'
                     )) AS result) a
           , JSON_TABLE (a.result, '$[*]' COLUMNS (
                             rid          VARCHAR2(18) PATH '$.rowid'
                           , score        NUMBER       PATH '$.score'
                           , vector_score NUMBER       PATH '$.vector_score'
                           , text_score   NUMBER       PATH '$.text_score'
                         )) b
           , rstr_info rstr
       WHERE rstr.rowid = b.rid;  
    languageId: oracle-sql
  - kind: 1
    value: "## 기타 참고사항"
    languageId: markdown
  - kind: 1
    value: 변수 바인드 대신, WITH 구문으로 대신하는 경우, APPROX로 지정해도 인덱스 타지 않음
    languageId: markdown
  - kind: 2
    value: >-
      EXPLAIN PLAN FOR

      WITH query AS (
        SELECT DBMS_VECTOR.UTL_TO_EMBEDDING('다국어 메뉴판이 있는 여의도 맛집', json(:params)) as query_vector FROM dual
      )
        SELECT id, VECTOR_DISTANCE(VECTOR_DESCRIPTION, query.query_vector, COSINE) AS vector_distance, business_type_registered, name, description
          FROM RSTR_INFO, query
        WHERE business_type_registered='한식'
      ORDER BY vector_distance

      FETCH APPROX FIRST 10 ROWS ONLY;


      SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY(format => 'ALL'));   
    languageId: oracle-sql
